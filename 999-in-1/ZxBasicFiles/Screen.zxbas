REM Write your ZX BASIC (Boriel's BASIC) code here

Dim screenCells(10, 20) as uByte
Dim workingCells(10, 20) as uByte
Dim ops(3, 200) as uByte
Dim currentOp as uByte

Dim screenSymbol(2, 2) as uByte
Dim workingSymbol(2, 2) as uByte

Dim screenScore as uInteger
Dim workingScore as uInteger

Dim screenLevel as uByte
Dim workingLevel as uByte

Dim sprites(22, 8) as uByte => { _
            { 64,64,64,64,64,64,64,64 }, _      'separador              a
            { 0,127,65,91,91,67,95,127 }, _     'cuadro                 b
            { 0,7,7,5,5,7,7,0 }, _              'simbolo 1              c
            { 0,112,112,80,80,112,112,0 }, _    'simbolo 2              d
            { 0,119,119,85,85,119,119,0 }, _    'simbolo 3              e
            { 0,0,119,68,36,20,119,0 }, _       'sc                     f
            { 0,0,119,85,86,85,117,0 }, _       'or                     g
            { 0,0,96,64,96,64,96,0 }, _         'e                      h
            { 0,0,54,69,38,20,100,0 }, _        'sp                     i
            { 0,0,119,68,102,68,119,0 }, _      'ee                     j
            { 0,0,192,160,160,160,192,0 }, _    'd                      k
            { 0,0,71,68,70,68,119,0 }, _        'le                     l
            { 0,0,87,84,86,84,39,0 }, _         've                     m
            { 0,0,64,64,64,64,112,0 }, _        'l                      n
            { 0,0,151,212,182,148,151,0 }, _    'ne                     o
            { 0,0,87,34,34,34,82,0 }, _         'xt                     p
            {255,199,187,187,187,199,255,255},_ 'esquina                q
            {255,85,170,255,170,85,255,0},_     '^                      r
            {93,107,93,107,93,107,93,107},_     '>                      s
            {0,255,170,85,255,85,170,255},_     '                       t
            {214,186,214,186,214,186,214,186}, _'<                      u
            { 0,54,69,37,22,20,100,0 }_         'sp (2)                 v
  }




Dim udgAddress as uInteger at 23675

const scrYCellsOffset as uInteger = 2
const scrXCellsOffset as uInteger = 7

const scrXCellCount as uInteger = 10
const scrYCellCount as uInteger = 20


const scrYScoreOffset as uInteger = scrYCellsOffset + 1
const scrXScoreOffset as uInteger = scrXCellsOffset + 12

const scrYNextOffset as uInteger = scrYCellsOffset + 5
const scrXNextOffset as uInteger = scrXCellsOffset + 12

const scrYSymbolOffset as uInteger = scrYCellsOffset + 6
const scrXSymbolOffset as uInteger = scrXCellsOffset + 11

const scrYLevelOffset as uInteger = scrYCellsOffset + 10
const scrXLevelOffset as uInteger = scrXCellsOffset + 12


function getPaddedText(StringToPad as string, PadChar as string, Length as uByte) as string

    Dim lenString as uByte = len(StringToPad)

    if lenString >= Length then return StringToPad(1 TO Length)

    Dim newStr as string = StringToPad
    Dim lp as uByte

    for lp = 1 to (Length - lenString)
        newStr = PadChar + newStr
    next lp

    return newStr

end function

sub InitScreen()

    udgAddress = @sprites

    ink 7
    paper 0
    bright 1
    border 0
    cls

    print at 0, 10; "9999 IN ONE"
    
    ink 1
    paper 7
    bright 0

    print at scrYCellsOffset, scrXCellsOffset; "\q\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\q"

    Dim buc as uByte
    for buc = 1 to 20
        print at scrYCellsOffset + buc, scrXCellsOffset; "\u               \s"
        print at scrYCellsOffset + buc, scrXCellsOffset + scrXCellCount + 1; "\a"
    next buc

    sprites(1,1) = 0
    sprites(1,2) = 0
    sprites(1,3) = 0
    sprites(1,4) = 0
    sprites(1,5) = 0
    sprites(1,6) = 0
    sprites(1,7) = 0
    sprites(1,8) = 0

    print at scrYCellsOffset + 21, scrXCellsOffset; "\q\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\q"

    ink 0
    paper 7
    bright 0


    print at scrYScoreOffset, scrXScoreOffset; "\f\g\h"
    print at scrYNextOffset, scrXNextOffset; "\o\p"
    print at scrYLevelOffset, scrXLevelOffset; "\l\m\n"

    workingScore = 9999
    workingLevel = 99

    FillRect(1,10,1,20,1)

    SetSymbol(%00001111,%00001111)

    pause 1
    UpdateScreen()

    workingScore = 0
    workingLevel = 1

    FillRect(1,10,1,20,0)

    SetSymbol(%00000000,%00000000)

    pause 50

    beep 0.1, 11
    beep 0.1, 14

    UpdateScreen()

end sub

sub InvertCell(x as uByte, y as uByte)

    if screenCells(x, y) = 0 then
        SetCell(x, y, 1)
    else
        SetCell(x, y, 0)
    end if

end sub

sub InvertRect(x1 as uByte, x2 as uByte, y1 as uByte, y2 as uByte)

    Dim x as uByte
    Dim y as uByte

    for y = y1 to y2
        for x = x1 to x2

            if screenCells(x, y) = 0 then
                SetCell(x, y, 1)
            else
                SetCell(x, y, 0)
            end if

        next x
    next y

end sub

sub MoveRect(x1 as Byte, x2 as Byte, y1 as Byte, y2 as Byte, xDisp as byte, yDisp as byte)

    Dim x as byte
    Dim y as byte

    for y = y1 to y2
        for x = x1 to x2
            SetCell(x, y, 0)
        next x
    next y

    for y = y1 to y2
        for x = x1 to x2
            SetCell(x + xDisp, y + yDisp, screenCells(x, y))
        next x
    next y

end sub

function DisplaceCollideRect(x1 as Byte, x2 as Byte, y1 as Byte, y2 as Byte, xDisp as byte, yDisp as byte) as uByte

    Dim x as byte
    Dim y as byte
    Dim st as uByte

    if xDisp <> 0 and yDisp <> 0 then return 255 'Diagonales no soportadas

    if yDisp > 0 then

        if y2 + yDisp > 20 then return 2

        for y = y1 to y2
            for x = x1 to x2
                if screenCells(x, y) <> 0 and screenCells(x, y + yDisp) then return 1 'colisiona
            next x
        next y

        for y = y1 to y2
            for x = x1 to x2
                st = screenCells(x, y)
                if st <> 0 then SetCell(x, y + yDisp, st)
            next x
        next y

        return 0

    else if yDisp < 0 then

        if y1 + yDisp < 1 then return 2

        for y = y2 to y1 step -1
            for x = x1 to x2
                if screenCells(x, y) <> 0 and screenCells(x, y + yDisp) then return 1 'colisiona
            next x
        next y

        for y = y2 to y1 step -1
            for x = x1 to x2
                st = screenCells(x, y)
                if st <> 0 then SetCell(x, y + yDisp, st)
            next x
        next y

        return 0

    else if xDisp > 0 then

        if x2 + xDisp > 10 then return 2
        
        for x = x1 to x2
            for y = y1 to y2
                if screenCells(x, y) <> 0 and screenCells(x + xDisp, y) then return 1 'colisiona
            
            next y
        next x

        for x = x1 to x2
            for y = y1 to y2
                st = screenCells(x, y)
                if st <> 0 then SetCell(x + xDisp, y, st)
            next y
        next x

        return 0

    else if xDisp < 0 then

        if x2 + xDisp < 1 then return 2
        
        for x = x2 to x1 step -1
            for y = y1 to y2
                if screenCells(x, y) <> 0 and screenCells(x + xDisp, y) then return 1 'colisiona
            
            next y
        next x

        for x = x2 to x1 step -1
            for y = y1 to y2
                st = screenCells(x, y)
                if st <> 0 then SetCell(x + xDisp, y, st)
            next y
        next x

        return 0

    else
        return 0
    end if

end function


sub FillRect(x1 as uByte, x2 as uByte,  y1 as uByte, y2 as uByte, state as uByte)

    Dim x as uByte
    Dim y as uByte

    for y = y1 to y2
        for x = x1 to x2

            SetCell(x, y, state)

        next x
    next y

end sub

sub SetCell(x as uByte, y as uByte, state as uByte)


    Dim opNum as uByte
    opNum = workingCells(x, y)

    if opNum <> 0 then
        
        if state <> screenCells(x, y) then
            ops(1, opNum) = x
        else
            ops(1, opNum) = 0
        end if

    else

        if screenCells(x, y) <> state then
            currentOp = currentOp + 1
            ops(1, currentOp) = x
            ops(2, currentOp) = y
            ops(3, currentOp) = state
            workingCells(x, y) = currentOp
        end if

    end if
        
end sub

sub SetSymbol(FirstRow as uByte, SecondRow as uByte)

    Dim tmpData as uByte

    tmpData = FirstRow band 3

    if tmpData = 0 then
        workingSymbol(2,1) = 0
    else
        workingSymbol(2,1) = tmpData + 1
    end if

    tmpData = (FirstRow >> 2) band 3

    if tmpData = 0 then
        workingSymbol(1,1) = 0
    else
        workingSymbol(1,1) = tmpData + 1
    end if

    tmpData = SecondRow band 3

    if tmpData = 0 then
        workingSymbol(2,2) = 0
    else
        workingSymbol(2,2) = tmpData + 1
    end if

    tmpData = (SecondRow >> 2) band 3

    if tmpData = 0 then
        workingSymbol(1,2) = 0
    else
        workingSymbol(1,2) = tmpData + 1
    end if

end sub

sub SetLevel(newLevel as uByte)
    workingLevel = newLevel
end sub

sub SetScore(newScore as uInteger)
    workingScore = newScore
end sub

sub UpdateScreen()

    Dim x as uByte
    Dim y as uByte
    Dim buc as uByte
    Dim oldValue as uByte
    Dim newValue as uByte

    if currentOp > 0 then

        for buc = 1 to currentOp

            x = ops(1, buc)
            if x <> 0 then

                y = ops(2, buc)

                newValue = ops(3, buc)

                screenCells(x, y) = newValue
                print at y + scrYCellsOffset, x + scrXCellsOffset; chr(144 + newValue)

            end if

        next buc

    end if

    for y = 1 to 2
        for x = 1 to 4

            oldValue = screenSymbol(x, y)
            newValue = workingSymbol(x, y)

            if oldValue <> newValue then

                screenSymbol(x, y) = newValue
                print at y + scrYSymbolOffset, x + scrXSymbolOffset; chr(144 + newValue)

            end if

        next x
    next y

    if workingScore <> screenScore then

        screenScore = workingScore
        print at scrYScoreOffset + 2, scrXScoreOffset; getPaddedText(str$(screenScore), "0", 4)

    end if

    if screenLevel <> workingLevel then

        screenLevel = workingLevel
        print at scrYLevelOffset + 2, scrXLevelOffset; getPaddedText(str$(screenLevel), "0", 2)

    end if

    currentOp = 0

    asm
        di
        ld de, _workingCells.__DATA__
        ld a, 0
        ld (de), a
        inc de
        ld hl, _workingCells.__DATA__
        ld bc, 199
        ldir
        ei

    end asm

end sub

